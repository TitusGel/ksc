#!/usr/bin/env python3
#
# See https://github.com/kotfu/kbdsc

import argparse
import re
import sys

# Features to be added
# - add a -t=mac, win option
# -

# to be removed later
import pytest

# constants
VERSION_STRING = "0.1.0"
EXIT_SUCCESS = 0
EXIT_ERROR = 1
EXIT_USAGE = 2


def _build_parser():
    """build an arg parser with all the proper parameters"""
    parser = argparse.ArgumentParser(
        description="Create a standardized representation of a macOS keyboard shortcut"
    )
    parser.add_argument("shortcuts", nargs="+", help="keyboard shortcut(s)")

    parser.add_argument(
        "-v",
        "--version",
        action="version",
        version=VERSION_STRING,
        help="show the version information and exit",
    )

    parser.add_argument(
        "-m",
        "--modifier-symbols",
        action="store_true",
        help="output modifier symbols instead of modifier names",
    )

    parser.add_argument(
        "-k",
        "--key-symbols",
        action="store_true",
        help="output key symbols instead of key names",
    )

    parser.add_argument(
        "-p",
        "--plus-sign",
        action="store_true",
        help="output + between modifier symbols, only used if -m",
    )

    parser.add_argument(
        "-y",
        "--hyper",
        action="store_true",
        help="parse and output the Hyper key as a modifier",
    )

    parser.add_argument(
        "-o",
        "--output",
        choices=["txt", "html"],
        default="txt",
        help="output format",
    )
    return parser


class Key:
    """store the name of a key, the html rendering of it, and a friendly text render of it"""

    def __init__(self, key, name, html):
        self.key = key
        self.name = name
        self.html = html


class MacOSKeyboardShortcut:
    """Parse, store, and render a keyboard shortcut in the macos flavor

    The canonical representation of a keyboard shortcut is the same as is used in macOS
    keyboard bindings files, ie:

    * = fn
    ^ = control
    $ = shift
    ~ = option
    @ = command

    The Hyper key is shorthand for Control-Shift-Option-Command

    """

    _hyper_mods = "^~$@"
    _hyper_name = "Hyper"

    # * isn't really a unicode version of the modifier, but it's included
    # here because we map between unicode and plaintext mods
    # these are in the order apple recommends they be presented
    _mods_plaintext = ["*", "^", "~", "$", "@"]
    _mods_unicode = ["*", "⌃", "⌥", "⇧", "⌘"]
    _mods_names = ["Fn", "Control", "Option", "Shift", "Command"]
    _unicode_plaintext_mods_trans = str.maketrans(
        "".join(_mods_unicode), "".join(_mods_plaintext)
    )

    # on parsing user input, allow specification of certain keynames
    # which may be mapped to the associated single character symbol
    # all names are in lower case
    # if a keyname is more than one character and not found in this list
    # then it is not valid
    _keyname_map = {
        "esc": "⎋",
        "escape": "⎋",
        "tab": "⇥",
        "caps": "⇪",
        "capslock": "⇪",
        "space": "␣",
        "eject": "⏏",
        "del": "⌫",
        "delete": "⌫",
        "back": "⌫",
        "backspace": "⌫",
        "fwddel": "⌦",
        "fwddelete": "⌦",
        "return": "↩",
        "rtn": "↩",
        "enter": "⌅",
        "ent": "⌅",
        "pageup": "⇞",
        "pgup": "⇞",
        "pagedown": "⇟",
        "pgdn": "⇟",
        "home": "↖",
        "end": "↘",
        "left": "←",
        "leftarrow": "←",
        "right": "→",
        "rightarrow": "→",
        "up": "↑",
        "uparrow": "↑",
        "down": "↓",
        "downarrow": "↓",
        "click": "leftclick",
        "leftclick": "leftclick",
        "rightclick": "rightclick",
        "rclick": "rightclick",
    }
    # programatically create 99 function keys
    _fkeys = []
    for num in range(1, 100):
        fkey = "F{}".format(num)
        _fkeys.append(fkey)

    # - if found in this dictionary, the "key" has an associated html entity,
    #   friendly name, and/or text description
    _keys = {
        "-": Key("-", "Hyphen", "Hyphen"),
        "⎋": Key("⎋", "Escape", "Escape??"),
        "⇥": Key("⇥", "Tab", "Tab"),
        "⇪": Key("⇪", "Caps Lock", "Caps Lock"),
        "␣": Key("␣", "Space", "Space"),
        "⏏": Key("⏏", "Eject", "Eject??"),
        "⌫": Key("⌫", "Delete", "Delete"),
        "⌦": Key("⌦", "Forward Delete", "Forward Delete"),
        "↩": Key("↩", "Return", "Return"),
        "⌅": Key("⌅", "Enter", "Enter"),
        "⇞": Key("⇞", "Page Up", "Page Up"),
        "⇟": Key("⇟", "Page Down", "Page Down"),
        "↖": Key("↖", "Home", "Home"),
        "↘": Key("↘", "End", "End"),
        "←": Key("←", "Left Arrow", "Left Arrow"),
        "→": Key("→", "Right Arrow", "Right Arrow"),
        "↑": Key("↑", "Up Arrow", "Up Arrow"),
        "↓": Key("↓", "Down Arrow", "Down Arrow"),
        "leftclick": Key("leftclick", "click", "click"),
        "rightclick": Key("rightclick", "right click", "right click"),
    }

    # shifted key translations
    _unshifted_keys = r",./;'[]\1234567890-="
    _shifted_keys = r'<>?:"{}|!@#$%^&*()_+'
    _to_shifted_trans = str.maketrans(_unshifted_keys, _shifted_keys)
    _to_unshifted_trans = str.maketrans(_shifted_keys, _unshifted_keys)

    def __init__(self, text, options):
        # mods is a string, key is also a string
        # if key is alphabetic, it's stored in upper
        # case
        #
        # if hyper is True, parse and output Hyper as a modifier key
        self.options = options
        self.mods, self.key = self._parse(text)
        self.canonical = "".join(self.mods) + self.key

    def __repr__(self):
        return "KeyboardShortcut({})".format(self.canonical)

    def __str__(self):
        return self.canonical

    def _parse(self, text):
        """parse input into a canonical non-unicode representation of the shortcut

        letters are always stored as upper case, special key names are always
        stored as lower case
        """
        # save the original text for an error message
        orig_text = text
        # Only remove hyphens preceeded and followed by non-space character
        # to avoid removing the last hyphen from 'option-shift--' or 'command -'
        text = re.sub(r"(?<=\S)-(?=\S)", " ", text)
        text = re.sub(r"\b(cont(rol)?|ctl|ctrl)\b", "^", text, re.IGNORECASE)
        text = re.sub(r"\bshift\b", "$", text, re.IGNORECASE)
        text = re.sub(r"\b(opt(ion)?|alt)\b", "~", text, re.IGNORECASE)
        text = re.sub(r"\b(comm(and)?|cmd|clover)\b", "@", text, re.IGNORECASE)
        text = re.sub(r"\b(func(tion)?|fn)\b", "*", text, re.IGNORECASE)
        if self.options.hyper:
            text = re.sub(r"\bhyper\b", "^$~@", text, re.IGNORECASE)
        mods = []
        key = ""
        # add other regexes here
        for char in text.strip():
            if char == " ":
                continue
            elif char in self._mods_unicode:
                # translate unicode modifier symbols to their plaintext equivilents
                mods.append(char.translate(self._unicode_plaintext_mods_trans))
            elif char in self._mods_plaintext:
                mods.append(char)
            else:
                key += char

        if len(key) == 1:
            if key in self._shifted_keys:
                # command % should be command shift 5
                # and command ? should be command shift ?
                # these ↓ are the shifted number keys
                mods.append("$")  # duplicates will get removed later
                # the unwritten apple rule that shifted numbers are
                # written as numbers not their symbols
                if key in "!@#$%^&*()":
                    key = key.translate(self._to_unshifted_trans)
            else:
                if "$" in mods:
                    # shift is in the mods, and the key is unshifted
                    # we should have the shifted symbol unless it is
                    # a number or letter
                    # command shift 5 should remain command shift 5
                    # and command shift r should remain command shift r
                    if key not in "0123456789":
                        # but shift command / should be shift command ?
                        key = key.translate(self._to_shifted_trans)

            # shortcuts always displayed with upper case letters
            key = key.upper()
        else:
            if key.lower() in self._keyname_map:
                # special key names, pgup, etc are in lowercase
                key = self._keyname_map[key.lower()]
            elif key.upper() in self._fkeys:
                # but function keys are in uppercase
                key = key.upper()
            else:
                raise ValueError("Could not parse '{}'".format(orig_text))

        # remove duplicate modifiers
        mods = list(set(mods))
        # sort the mods to be in Apple's recommended order
        mods.sort(key=lambda x: self._mods_plaintext.index(x))

        return ("".join(mods), key)

    def render(self):
        tokens = []
        joiner = ""
        if self.options.modifier_symbols:
            if self.options.plus_sign:
                joiner = "+"
            tokens.extend(self.mod_symbols)
        else:
            joiner = "-"
            tokens.extend(self.mod_names)
        if self.options.key_symbols:
            tokens.extend(self.key)
        else:
            tokens.append(self.key_name)
        return joiner.join(tokens)

    @property
    def mod_names(self):
        """return a list of modifier names for this shortcut"""
        output = []
        if self.mods == self._hyper_mods:
            output.append(self._hyper_name)
        else:
            for mod in self.mods:
                output.append(self._mods_names[self._mods_plaintext.index(mod)])
        return output

    @property
    def mod_symbols(self):
        """return a list of unicode symbols for this shortcut"""
        output = []
        for mod in self.mods:
            output.append(self._mods_unicode[self._mods_plaintext.index(mod)])
        return output

    @property
    def key_name(self):
        """return either the key, or if it has a name return that"""
        if self.key in self._keys:
            return self._keys[self.key].name
        # this is for human consumption, and keys are always upper case
        return self.key.upper()


def _parse_shortcuts(args):
    """parse a string or array of text into a standard representation of the shortcut

    returns an array of shortcut combinations

    this is a short function only called in one place, but it makes it much easier
    to test
    """
    combos = []
    for combo in re.split(r" / ", " ".join(args.shortcuts)):
        combos.append(MacOSKeyboardShortcut(combo, args))
    return combos


def _render_txt(combos, args):
    """render as plain text a list of keyboard combinations according to the
    options in args"""
    output = []
    for combo in combos:
        output.append(combo.render())

    return " ".join(output)


def main(argv=None):
    """main function"""
    parser = _build_parser()
    args = parser.parse_args(argv)
    combos = _parse_shortcuts(args)

    if args.output == "txt":
        print(_render_txt(combos, args))
    elif args.output == "html":
        pass


if __name__ == "__main__":
    sys.exit(main())


#
# embedded tests
#
# to run the test simply do
#
#   $ pytest kbdsc.py
#
# you can't use pytest decorators with this method, but you also don't
# import pytest and mock unless you run the tests. Tradeoffs. If you want
# to use decorators, move the imports in setup_module() to the top and then
# delete that function


# def setup_module():
#    global pytest
#    global mock
#    import pytest
#    import mock


@pytest.mark.parametrize(
    "argv, parsed",
    [
        ("command %", "$@5"),
        ("command shift %", "$@5"),
        ("command shift 5", "$@5"),
        ("shift control 6", "^$6"),
        ("shift-command-/", "$@?"),
        ("command shift /", "$@?"),
        ("shift control \\", "^$|"),
        ("control \\", "^\\"),
        ("command ?", "$@?"),
        ("command f", "@F"),
        ("command option r", "~@R"),
        ("⌘⌥⇧⌃r", "^~$@R"),
        ("command-shift-f", "$@F"),
        ("func f2", "*F2"),
        ("fn F13", "*F13"),
        ("F7", "F7"),
        ("control command  shift control H", "^$@H"),
        ("  command -", "@-"),
        ("command command q", "@Q"),
        ("H", "H"),
        ("shift h", "$H"),
        ("command control R", "^@R"),
        ("shift p", "$P"),
        ("shift 4", "$4"),
        ("ctrl 6", "^6"),
        ("command right", "@→"),
        ("control command del", "^@⌫"),
        ("shift ESCAPE", "$⎋"),
        ("control click", "^leftclick"),
        ("option rightclick", "~rightclick"),
        ("-y hyper 5", "^~$@5"),
    ],
)
def test_mac_parse(argv, parsed):
    parser = _build_parser()
    args = parser.parse_args(argv.split())
    combos = _parse_shortcuts(args)

    assert parsed == combos[0].canonical


@pytest.mark.parametrize(
    "argv, out",
    [
        ("$@5", "Shift-Command-5"),
        ("-m $@5", "⇧⌘5"),
        ("-mp $@5", "⇧+⌘+5"),
        ("-y hyper 5", "Hyper-5"),
        ("-ymp hyper 5", "⌃+⌥+⇧+⌘+5"),
        ("^leftclick", "Control-click"),
        ("~rightclick", "Option-right click"),
    ],
)
def test_mac_render(argv, out):
    parser = _build_parser()
    args = parser.parse_args(argv.split())
    combos = _parse_shortcuts(args)
    assert out == _render_txt(combos, args)


# def test_ks_parse():
#     parsemap = [
#         ("command %", "$@5"),
#         ("command shift %", "$@5"),
#         ("command shift 5", "$@5"),
#         ("shift-command-/", "@?"),
#         ("command ?", "@?"),
#         ("command f", "@F"),
#         ("command option r", "~@R"),
#         ("⌘⌥⇧⌃r", "^~$@R"),
#         ("command-shift-f", "$@F"),
#         ("func 2", "*2"),
#         ("command shift /", "@?"),
#         ("control command  shift control H", "^$@H"),
#         ("  command -", "@-"),
#         ("command command q", "@Q"),
#         ("shift control \\", "^|"),
#         ("H", "H"),
#         ("shift h", "$H"),
#         ("command control R", "^@R"),
#         ("shift p", "$P"),
#         ("shift 4", "$"),
#         ("ctrl 6", "^6"),
#         ("shift control 6", "^$^"),
#         ("command right", "@→"),
#         ("control command del", "^@⌫"),
#         ("shift ESCAPE", "$⎋"),
#         ("F7", "f7"),
#     ]
#     for text, canonical in parsemap:
#         ks = KeyboardShortcut(text)
#         assert str(ks) == canonical


def test_ks_parse_error():
    argvs = [
        "Q99",
        "F0",
        "F100",
        "fred",
        "command - shift 5",
    ]
    parser = _build_parser()
    for argv in argvs:
        args = parser.parse_args(argv.split())
        with pytest.raises(ValueError):
            combos = _parse_shortcuts(args)


def test_parse_3():
    parser = _build_parser()
    argv = "F10 / shift-escape / control-option-right"
    args = parser.parse_args(argv.split())
    combos = _parse_shortcuts(args)
    assert len(combos) == 3
