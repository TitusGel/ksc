#!/usr/bin/env python3
#
# Copyright (c) 2021 kotfu
# Distributed under the MIT License
# See https://github.com/kotfu/ksc

import argparse
import re
import sys
import textwrap


# constants
VERSION_STRING = "1.0.0"
EXIT_SUCCESS = 0
EXIT_ERROR = 1
EXIT_USAGE = 2


def _build_parser():
    """build an arg parser with all the proper parameters"""
    desc = "Create a standardized representation of a MacOS keyboard shortcut."
    epilog = """\
        Keyboard shortcuts can be entered in many ways:

            command shift F
            option command h
            control option command space

        Separate multiple shortcuts with ' / ' or ' | ':

            control x / control c

        See https://github.com/kotfu/ksc for more info
        """
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=desc,
        epilog=textwrap.dedent(epilog),
    )
    parser.add_argument("shortcuts", nargs="*", help="keyboard shortcuts")

    parser.add_argument(
        "-v",
        "--version",
        action="version",
        version=VERSION_STRING,
        help="show the version information and exit",
    )
    mod_group = parser.add_mutually_exclusive_group()
    mod_group.add_argument(
        "-ma",
        "--modifier-ascii",
        action="store_true",
        help="output modifiers as ASCII characters instead of modifier names",
    )
    mod_group.add_argument(
        "-ms",
        "--modifier-symbols",
        action="store_true",
        help="output modifier symbols instead of modifier names",
    )
    parser.add_argument(
        "-p",
        "--plus-sign",
        action="store_true",
        help="output + between modifier symbols, only used if -ms",
    )
    parser.add_argument(
        "-y",
        "--hyper",
        action="store_true",
        help="output Hyper as a modifier name",
    )

    parser.add_argument(
        "-k",
        "--key-symbols",
        action="store_true",
        help="output key symbols instead of key names",
    )
    parser.add_argument(
        "-c",
        "--clarify-keys",
        action="store_true",
        help="clarify hard to read keys by spelling out their name, ignored if -k",
    )

    parser.add_argument(
        "-l",
        "--list",
        action="store_true",
        help="list all modifier and key names",
    )
    # potential future options, here for planning
    #
    # parser.add_argument(
    #     "-o",
    #     "--output",
    #     choices=["txt", "html", "json"],
    #     default="txt",
    #     help="output format",
    # )
    # parser.add_argument(
    #     "-s",
    #     "--style",
    #     choices=["mac", "win"],
    #     default="mac",
    #     help="style of shortcut based on operating system",
    # )
    # parser.add_argument(
    #     "-t",
    #     "--template",
    #     help="tempate to use for html output",
    # )
    return parser


class Key:
    """store the name of a key, input names, ane render names for that key"""

    def __init__(
        self,
        key,
        name,
        input_names=None,
        shifted_key=None,
        html_entity=None,
        clarified_name=None,
        ascii=None,
        modifier=False,
    ):
        self.key = key
        """The (usually) single character representation of the key. For modifiers and
        most other named keys, we use the unicode representation, i.e. ⌘ for command,
        → for Right Arrow, etc."""

        self.name = name
        """The name of this key spelled out, ie the ← key is Left Arrow. If
        the key is F, the name is F."""

        self.input_names = input_names
        """A list of names which a user can input to reference this key"""

        self.shifted_key = shifted_key
        """If the key has a different output when the shift key is pressed, put
        the shifted value here"""

        self.clarified_name = clarified_name
        """Some keys can benefit from a clarified name, like Period (.) instead of ."""

        self.html_entity = html_entity
        """If this key has an HTML entity, store it here"""

        self.modifier = modifier
        """True if this key is a modifier key, like Fn, Shift, etc."""

        self.ascii = ascii
        """If the key is a modifier, it also has an ASCII representation, like ~ for Option"""


# make a list of keys, if the key isn't in this list (like F or R), then
# it's just a single character key with nothing special about it
class MacOS:
    """The keys and their properties for MacOS

    Includes methods to parse user input into shortcuts
    """

    keys = [
        # '*' is not unicode for Fn, but their isn't one, and we need something
        # that is a single character
        # order matters for the modifier keys, they need to be in the apple
        # recommended order for displaying modifier keys
        Key("*", "Fn", ["func", "function", "fn"], ascii="*", modifier=True),
        Key(
            "⌃",  # this is not a caret, it's another unicode character
            "Control",
            ["control", "cont", "ctrl", "ctl"],
            ascii="^",  # this one is a caret
            modifier=True,
        ),
        Key("⌥", "Option", ["option", "opt", "alt"], ascii="~", modifier=True),
        Key("⇧", "Shift", ["shift", "shft"], ascii="$", modifier=True),
        Key("⌘", "Command", ["command", "cmd", "clover"], ascii="@", modifier=True),
        Key("⎋", "Escape", ["escape", "esc"]),
        Key("⇥", "Tab", ["tab"]),
        Key("⇪", "Caps Lock", ["capslock", "caps"]),
        Key("␣", "Space", ["space"]),
        Key("⏏", "Eject", ["eject"]),
        Key("⌫", "Delete", ["delete", "del"]),
        Key(
            "⌦",
            "Forward Delete",
            ["forwarddelete", "fwddelete", "forwarddel", "fwddel"],
        ),
        Key("⌧", "Clear", ["clear"], clarified_name="Clear (⌧)"),
        Key("↩", "Return", ["return", "rtn"]),
        Key("⌅", "Enter", ["enter", "ent"]),
        Key("⇞", "Page Up", ["pageup", "pgup"]),
        Key("⇟", "Page Down", ["pagedown", "pgdown"]),
        Key("↖", "Home", ["home"]),
        Key("↘", "End", ["end"]),
        Key("←", "Left Arrow", ["leftarrow", "left"]),
        Key("→", "Right Arrow", ["rightarrow", "right"]),
        Key("↑", "Up Arrow", ["uparrow", "up"]),
        Key("↓", "Down Arrow", ["downarrow", "down"]),
        Key("leftclick", "click", ["leftclick", "click"]),
        Key("rightclick", "right click", ["rightclick", "rclick"]),
        Key(
            "`",
            "`",
            ["grave", "backtick", "backquote"],
            shifted_key="~",
            clarified_name="Grave (`)",
        ),
        Key("~", "~", ["tilde"], clarified_name="Tilde (~)"),
        Key("1", "1", shifted_key="!"),
        Key("2", "2", shifted_key="@"),
        Key("3", "3", shifted_key="#"),
        Key("4", "4", shifted_key="$"),
        Key("5", "5", shifted_key="%"),
        Key("6", "6", shifted_key="^"),
        Key("7", "7", shifted_key="&"),
        Key("8", "8", shifted_key="*"),
        Key("9", "9", shifted_key="("),
        Key("0", "0", shifted_key=")"),
        Key("-", "-", ["minus"], shifted_key="_", clarified_name="Minus Sign (-)"),
        Key("_", "_", ["underscore"], clarified_name="Underscore (_)"),
        Key("=", "=", ["equals", "equal"], shifted_key="+"),
        Key("+", "+", ["plus"], clarified_name="Plus Sign (+)"),
        Key("[", "[", shifted_key="{"),
        Key("]", "]", shifted_key="}"),
        Key("\\", "\\", ["backslash"], shifted_key="|"),
        Key("|", "|", ["pipe"]),
        Key(
            ";",
            ";",
            ["semicolon", "semi"],
            shifted_key=":",
            clarified_name="Semicolon (;)",
        ),
        Key(
            "'",
            "'",
            ["singlequote", "sq"],
            shifted_key='"',
            clarified_name="Single Quote (')",
        ),
        Key('"', '"', ["doublequote", "dq"], clarified_name='Double Quote (")'),
        Key(",", ",", ["comma"], shifted_key="<", clarified_name="Comma (,)"),
        Key(".", ".", ["period"], shifted_key=">", clarified_name="Period (.)"),
        Key("/", "/", ["slash"], shifted_key="?", clarified_name="Slash (.)"),
        Key("?", "?", ["questionmark", "question"]),
    ]
    # programatically create 35 function keys
    # we choose 35 because that's how many are defined in NSEvent()
    # see https://developer.apple.com/documentation/appkit/1535851-function-key_unicodes?preferredLanguage=occ
    for _num in range(1, 36):
        _fkey = "F{}".format(_num)
        keys.append(Key(_fkey, _fkey, [_fkey.lower()]))

    #
    # construct various data structures from keys, which are the authoritative
    # source
    hyper_mods = "^~$@"
    hyper_name = "Hyper"
    hyper_regex = r"\b" + hyper_name.lower() + r"\b"

    mods_names = []
    mods_plaintext = []
    mods_unicode = []
    unshifted_keys = ""
    shifted_keys = ""
    mods_regex_map = []
    for _key in keys:
        if _key.modifier:
            mods_names.append(_key.name)
            mods_plaintext.append(_key.ascii)
            mods_unicode.append(_key.key)
            _regex = r"\b(" + "|".join(_key.input_names) + r")\b"
            mods_regex_map.append((_key.ascii, _regex))
        if _key.shifted_key:
            unshifted_keys += _key.key
            shifted_keys += _key.shifted_key

    # make some translation tables
    unicode_plaintext_mods_trans = str.maketrans(
        "".join(mods_unicode), "".join(mods_plaintext)
    )
    to_shifted_trans = str.maketrans(unshifted_keys, shifted_keys)
    to_unshifted_trans = str.maketrans(shifted_keys, unshifted_keys)
    # and a keyname dictionary lookup
    keyname_map = {}
    for _key in keys:
        if _key.input_names:
            for _name in _key.input_names:
                keyname_map[_name] = _key

    @classmethod
    def named_keys(cls, args):
        """Return a string containing a formatted list of all known keys"""
        # start with the modifiers
        output = []
        fmt = "{:12} {:18} {}"
        output.append(fmt.format("Key", "Name", "Inputs"))
        output.append(fmt.format("-" * 12, "-" * 18, "-" * 50))
        keyflag = True
        for key in cls.keys:
            if key.modifier is False and keyflag is True:
                if args.hyper:
                    output.append(
                        fmt.format(" ", cls.hyper_name, cls.hyper_name.lower())
                    )
                keyflag = False
            if key.key != key.name or key.clarified_name or key.input_names:
                output.append(
                    fmt.format(
                        key.key,
                        key.clarified_name or key.name,
                        ",".join(key.input_names if key.input_names else ""),
                    )
                )
        return "\n".join(output)

    @classmethod
    def parse_shortcuts(cls, shortcuts):
        """parse a string or array of text into a standard representation of the shortcut

        shortcuts = a string of text to be parsed

        uses args from the command line to influence parsing behavior

        returns an array of shortcut combinations
        """
        combos = []
        for combo in re.split(r" [/|] ", shortcuts):
            combos.append(cls.parse_shortcut(combo))
        return combos

    @classmethod
    def parse_shortcut(cls, text):
        """parse a string and return a MacOSKeyboardShortcut object

        Raises ValueError if string can't be parsed

        """

        """parse input into a canonical non-unicode representation of the shortcut

        letters are always stored as upper case, special key names are always
        stored as lower case
        """
        # save the original text for an error message
        orig_text = text
        mods = []
        key = ""
        # Only remove hyphens preceeded and followed by non-space character
        # to avoid removing the last hyphen from 'option-shift--' or 'command -'
        text = re.sub(r"(?<=\S)-(?=\S)", " ", text)
        # remove words that represent modifiers from the text, and add them
        # to the 'mods' array
        for (modkey, regex) in cls.mods_regex_map:
            (text, cnt) = re.subn(regex, "", text, re.IGNORECASE)
            if cnt:
                mods.append(modkey)
        # look for the hyper key
        (text, cnt) = re.subn(cls.hyper_regex, "", text, re.IGNORECASE)
        if cnt:
            for modkey in cls.hyper_mods:
                mods.append(modkey)

        # process the remainder of the text
        for char in text.strip():
            if char == " ":
                continue
            elif char in cls.mods_unicode:
                # translate unicode modifier symbols to their plaintext equivilents
                mods.append(char.translate(cls.unicode_plaintext_mods_trans))
            elif char in cls.mods_plaintext and char not in mods:
                # but since plaintext modifiers could also be a key, aka
                # @$@ really means command-shift-2, we only treat the first
                # occurance of a plaintext modifier as a modifier, subsequent
                # occurances are the key
                mods.append(char)
            else:
                key += char

        # map key names to key symbols
        if key.lower() in cls.keyname_map:
            # special key names, pgup, etc are in lowercase
            key = cls.keyname_map[key.lower()].key

        if len(key) == 1:
            if key in cls.shifted_keys:
                # command % should be command shift 5
                # and command ? should be command shift ?
                # these ↓ are the shifted number keys
                mods.append("$")  # duplicates will get removed later
                # the unwritten apple rule that shifted numbers are
                # written as numbers not their symbols
                if key in "!@#$%^&*()":
                    key = key.translate(cls.to_unshifted_trans)
            else:
                if "$" in mods:
                    # shift is in the mods, and the key is unshifted
                    # we should have the shifted symbol unless it is
                    # a number or letter
                    # command shift 5 should remain command shift 5
                    # and command shift r should remain command shift r
                    if key not in "0123456789":
                        # but shift command / should be shift command ?
                        key = key.translate(cls.to_shifted_trans)

            # shortcuts always displayed with upper case letters
            key = key.upper()
        else:
            if key.lower() in cls.keyname_map:
                # these are the function keys because they are in the map
                # and the key name is longer than a single character
                # either way, if the key is in the map then it's valid
                pass
            else:
                raise ValueError("Could not parse '{}'".format(orig_text))

        # remove duplicate modifiers
        mods = list(set(mods))
        # sort the mods to be in Apple's recommended order
        mods.sort(key=lambda x: cls.mods_plaintext.index(x))

        return MacOSKeyboardShortcut("".join(mods), key)


class MacOSKeyboardShortcut:
    """Store and render a keyboard shortcut in the macos flavor

    When this object is created, it expects the modifiers, if present, are in the
    correct order as specified by the Apple Style Guidelines. This occurs in
    MacOS.parse_shortcut().

    """

    def __init__(self, mods, key):
        """
        mods is a list of ascii symbols representing key modifiers
        key is the keyname (i.e L, ←, 5 or F12)
        options are the rendering options to use for this key
        """
        self.mods = mods
        self.key = key
        self.canonical = self.mods + self.key

    def __repr__(self):
        return "KeyboardShortcut({})".format(self.canonical)

    def __str__(self):
        return self.canonical

    def render(self, options):
        """render this key as a string for human consumption"""
        tokens = []
        joiner = ""
        if options.modifier_symbols:
            if options.plus_sign:
                joiner = "+"
            tokens.extend(self.mod_symbols())
        elif options.modifier_ascii:
            joiner = ""
            tokens.extend(self.mods)
        else:
            joiner = "-"
            tokens.extend(self.mod_names(options))
        if options.key_symbols:
            tokens.extend(self.key)
        else:
            tokens.append(self.key_name(options))
        return joiner.join(tokens)

    def mod_names(self, options):
        """return a list of modifier names for this shortcut"""
        output = []
        if options.hyper and self.mods == MacOS.hyper_mods:
            output.append(MacOS.hyper_name)
        else:
            for mod in self.mods:
                output.append(MacOS.mods_names[MacOS.mods_plaintext.index(mod)])
        return output

    def mod_symbols(self):
        """return a list of unicode symbols for this shortcut"""
        output = []
        for mod in self.mods:
            output.append(MacOS.mods_unicode[MacOS.mods_plaintext.index(mod)])
        return output

    def key_name(self, options):
        """return either the key, or if it has a name return that"""
        # find the key object, if it exists
        keyobj = None
        for keytest in MacOS.keys:
            if self.key == keytest.key:
                keyobj = keytest
                break
        # if we have a key object, then use it's name and clarified name
        if keyobj:
            if options.clarify_keys and keyobj.clarified_name:
                return keyobj.clarified_name
            return keyobj.name
        # otherwise
        return self.key


def main(argv=None):
    """main function"""
    parser = _build_parser()
    args = parser.parse_args(argv)

    if args.list:
        # list all available keys, don't parse any input
        print(MacOS.named_keys(args))
        return EXIT_SUCCESS

    combos = MacOS.parse_shortcuts(" ".join(args.shortcuts))
    output = []
    for combo in combos:
        output.append(combo.render(args))
    print(" ".join(output))
    return EXIT_SUCCESS


if __name__ == "__main__":
    sys.exit(main())


#
# embedded tests
#
# pytest will only collect tests in files that end in .py
# to run the tests do
#
#   $ ln -s ksc ksc.py
#   $ pytest ksc.py
#
# you can't use pytest decorators with this method, but you also don't
# import pytest unless you run the tests. Tradeoffs. If you want
# to use decorators, move the imports in setup_module() to the top and then
# delete that function


def setup_module():
    global pytest
    import pytest


def test_mac_parse():
    parsemap = [
        ("command 2", "@2"),
        ("@2", "@2"),
        ("command shift 2", "$@2"),
        ("command %", "$@5"),
        ("command shift %", "$@5"),
        ("command shift 5", "$@5"),
        ("shift control 6", "^$6"),
        ("^$6", "^$6"),
        ("shift-command-/", "$@?"),
        ("command shift /", "$@?"),
        ("shift control \\", "^$|"),
        ("control \\", "^\\"),
        ("control shift `", "^$~"),
        ("^$`", "^$~"),
        ("command ?", "$@?"),
        ("command f", "@F"),
        ("command option r", "~@R"),
        ("⌘⌥⇧⌃r", "^~$@R"),
        ("command-shift-f", "$@F"),
        ("func f2", "*F2"),
        ("fn F13", "*F13"),
        ("F7", "F7"),
        ("control command  shift control H", "^$@H"),
        ("  command -", "@-"),
        ("command command q", "@Q"),
        ("H", "H"),
        ("shift h", "$H"),
        ("command control R", "^@R"),
        ("shift p", "$P"),
        ("shift 4", "$4"),
        ("ctrl 6", "^6"),
        ("command right", "@→"),
        ("control command del", "^@⌫"),
        ("shift ESCAPE", "$⎋"),
        ("control click", "^leftclick"),
        ("option rightclick", "~rightclick"),
        ("hyper 5", "^~$@5"),
        ("command dq", '$@"'),
        ("command tilde", "$@~"),
    ]
    for (inp, parsed) in parsemap:
        shortcut = MacOS.parse_shortcut(inp)
        assert parsed == shortcut.canonical


def test_mac_parse_error():
    fails = [
        "Q99",
        "F0",
        "F100",
        "fred",
        "command - shift 5",
        "control ^F",
        "^$~",
    ]
    for inp in fails:
        with pytest.raises(ValueError):
            combos = MacOS.parse_shortcuts(inp)


def test_mac_parse_multiple():
    parsemap = [
        ("F10 / shift-escape / control-option-right", 3),
        ("control x | control c", 2),
    ]
    for inp, count in parsemap:
        combos = MacOS.parse_shortcuts(inp)
    assert len(combos) == count


def test_mac_render(capsys):
    rendermap = [
        ("$@5", "Shift-Command-5"),
        ("-ms $@5", "⇧⌘5"),
        ("-ms -p $@5", "⇧+⌘+5"),
        ("^~$@R", "Control-Option-Shift-Command-R"),
        ("-y ^~$@R", "Hyper-R"),
        ("-y hyper 5", "Hyper-5"),
        ("-yp -ms hyper 5", "⌃+⌥+⇧+⌘+5"),
        ("^leftclick", "Control-click"),
        ("~rightclick", "Option-right click"),
        ("-c @.", "Command-Period (.)"),
        ("@⌫", "Command-Delete"),
    ]
    for (cmdline, result) in rendermap:
        argv = cmdline.split(" ")
        exit_code = main(argv)
        out, err = capsys.readouterr()
        out = out.rstrip()
        assert out == result


def test_mac_list(capsys):
    argv = "-l".split(" ")
    exit_code = main(argv)
    out, err = capsys.readouterr()
    assert not MacOS.hyper_name in out
    assert "Command" in out


def test_mac_list_hyper(capsys):
    argv = "-ly".split(" ")
    exit_code = main(argv)
    out, err = capsys.readouterr()
    assert MacOS.hyper_name in out
